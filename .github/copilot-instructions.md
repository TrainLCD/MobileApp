# TrainLCD GitHub Copilot 指示書

このドキュメントは、TrainLCD モバイルアプリケーションの開発において GitHub Copilot を効果的に活用するためのガイドラインです。

> **注**: このファイルは GitHub Copilot 専用の指示書です。自動化エージェント全般向けの英語ガイドラインは`AGENTS.md`を参照してください。両ファイル間で競合がある場合、リポジトリオーナー・メンテナーの指示を優先してください。

## 基本原則

- **対話言語**: GitHub Copilot との対話は**日本語**で行ってください
- **コードレビュー**: コードレビューやフィードバックも日本語で提供してください
- **コメント言語**: コード内のコメントは日本語または英語のいずれかで記述可能ですが、一貫性を保ってください
- **コミットメッセージ生成**: コミットメッセージも日本語で生成してください

## プロジェクト概要

TrainLCD は、日本の鉄道会社の LCD 画面を再現し、リアルタイムのナビゲーションと駅情報を提供するモバイルアプリケーションです。Expo React Native を使用して、iOS・Android 両プラットフォーム向けに開発されています。

## コーディング規約

### 命名規則

- **コンポーネント**: PascalCase（例: `StationBanner.tsx`）
- **フック**: `use`プレフィックス（例: `useStationFeed.ts`）
- **Zustand ストア**: `*Store.ts`サフィックス（例: `navigationStore.ts`）
- **GraphQL 操作**: `FeatureVerbQuery`形式（例: `GetStationListQuery`）

### コードスタイル

- **インデント**: 2 スペース（`.editorconfig`で定義）
- **引用符**: シングルクォート
- **末尾カンマ**: ES5 形式
- **文字コード**: UTF-8
- **フォーマッター**: Biome を使用
- **Linter**: Biome を使用

### コメント記述

- 実装の意図や制約を説明する目的でコメントを記述
- 自明な内容は避け、非自明なロジックのみコメント
- `// biome-ignore`は真に互換性のない場合のみ使用し、理由をインラインで記述

## プロジェクト構造

```
src/
├── components/        # 再利用可能なUIコンポーネント
├── screens/           # 画面コンポーネント
├── hooks/             # カスタムReactフック
├── store/             # Zustandストアとセレクター
├── stacks/            # React Navigationスタック定義
├── providers/         # Contextプロバイダーと統合ラッパー
├── lib/               # APIクライアントと共有統合
├── config/            # 静的設定ヘルパー
├── constants/         # 共有定数
├── utils/             # ユーティリティ関数とテストヘルパー
├── test/              # テストユーティリティとe2eハーネス
├── __mocks__/         # Jestモック
├── __fixtures__/      # テストフィクスチャ
├── @types/            # グローバルTypeScript型定義
└── models/            # データモデル
```

### ファイル配置の原則

- スタイルモジュールや定数は利用箇所の近くに配置
- 横断的なユーティリティは`src/utils/`で共有
- テストは対象モジュールと同じ階層に`.test.ts`または`.test.tsx`として配置

## 技術スタック

- **React Native** + **Expo**: クロスプラットフォーム開発
- **TypeScript**: 型安全性と開発者体験の向上
- **React Navigation**: ナビゲーション管理
- **Tanstack Query**: データフェッチングとキャッシング
- **Zustand**: 状態管理
- **Firebase**: バックエンドサービス（Analytics、Auth、Firestore、Storage）
- **Sentry**: エラートラッキングとパフォーマンス監視
- **GraphQL**: 型付きクエリとオペレーション

## 開発環境

- **Node.js 20.x**を使用
- **pnpm 10.x**を使用（グローバルインストール版、Corepack は不要）
- Metro キャッシュ問題が発生した場合のみ`expo start --clear`を実行
- GraphQL codegen には`.env.local`に`GQL_API_URL`が必要

## 主要コマンド

```bash
pnpm start              # Expo開発サーバー起動
pnpm android / pnpm ios # ネイティブビルド（Fastlane経由）
pnpm web               # Web版実行
pnpm lint              # Biome Lint実行
pnpm format            # Biomeフォーマット適用
pnpm test              # Jestテスト実行（UTC環境）
pnpm typecheck         # TypeScript型チェック
pnpm gql:codegen       # GraphQL型定義再生成
```

## テスト戦略

### テストの基本方針

- Jest のグローバルセットアップは`jest.setup.js`と`src/setupTests.ts`で管理
- 単体テストは対象モジュールと同じ階層に`.test.ts`/`.test.tsx`として配置
- テストヘルパーは`src/utils/test/`から再利用
- ネットワークと Firebase レイヤーは`jest.mock`でモック化
- `afterEach`で`jest.clearAllMocks()`を呼び出す
- 統合フローのテストは`src/test/e2e.ts`を拡張
- フィクスチャは`src/__fixtures__/`から利用

### テスト作成時の注意点

- 挙動を変更する際は、同じ変更セット内でテストも更新または追加
- スキップされたテストは TODO コメントで理由と担当者を記載

## コード変更時のチェックリスト

コード変更を行う際は、以下を確認してください：

- [ ] 要件を確認し、競合する要求があれば報告
- [ ] コード変更に関連するテストを更新または追加
- [ ] `pnpm lint`、`pnpm test`、`pnpm typecheck`を実行し、結果を記録
- [ ] 挙動が変わる場合はドキュメント（README、docs/、インラインコメント）を更新
- [ ] UI 変更の場合はスクリーンショット/動画をデバイス名とともに記録

## コミット規約

- コミットメッセージは日本語で記述してください（例: `テレメトリー送信機をリファクタリングしてnull状態を回避`）
- 本番環境のホットフィックスには`Hotfix:`プレフィックスを付与
- コミットは論理的な単位（実装、テスト、ドキュメント）で分割
- 生成されたファイルはコミットメッセージで言及

## プルリクエストのガイドライン

プルリクエストには以下を含めてください：

- 目的と主要な変更内容の要約
- リグレッションリスクの評価と軽減策
- ローカルで実行したコマンド（例: `pnpm lint && pnpm test && pnpm typecheck`）
- 関連する Issue またはチケットへのリンク
- UI/UX 変更の場合はスクリーンショットまたは録画（デバイス名を記載、例: Pixel 8、iPhone 15 Pro）

CI が失敗した場合は、根本原因のメモと再現手順を追加するか、インフラストラクチャの問題について Issue を作成してからレビューを進めてください。

## セキュリティとコンフィグレーション

- シークレットは`.env.local`に保存
- `.env`をテンプレートとして扱い、`.env.example`をオンボーディング用に同期
- クレデンシャル、アクセストークン、本番エンドポイントは絶対にコミットしない
- 既存の GitHub Actions シークレット名（例: `FONTS_SSH_KEY`）を再利用してドリフトを防止
- 依存関係のアップグレード（`pnpm up --interactive`）や Expo SDK マイグレーション後は、`expo-doctor`、`pnpm lint`、`pnpm test`、`pnpm typecheck`を実行し、結果を`docs/changelog.md`に記録

## AI 支援開発の原則

GitHub Copilot を使用する際は、以下の原則に従ってください：

1. **指示の優先順位**: リポジトリオーナー・メンテナー → 最新タスクプロンプト → このハンドブック → その他のドキュメント
2. **作業ツリーの保護**: 現在のスナップショットを基準に操作し、ユーザーの変更を破棄しない。破壊的なコマンド（`git reset --hard`、`git clean -fd`など）は使用しない
3. **最小限の監査可能な差分**: 追加的な編集を優先し、フォーマットを決定論的に保ち、自明でない変更には簡潔なコメントを付与
4. **再現性の文書化**: 実行したすべてのコマンドを記録し、環境変数やクレデンシャルに関するローカルな前提を記載
5. **前提の積極的な検証**: キャッシュされた知識に頼らず、ツールのバージョン、ワークフローの期待、環境のニーズを確認
6. **不確実性の明確化**: 意図を推測するのではなく、ガイダンスを要求するか、TODO ノートを残す

## 標準ワークフロー

1. **取り込み**: Issue、PR ディスカッション、プロンプト全体を読み、コーディング前に成果物と制約を再確認
2. **偵察**: `rg`、`ls`、`find`で関連ファイルをマッピング。インターフェースと既存パターンを確認して互換性のある変更を計画
3. **計画**: 個別のステップを概説し、進捗に応じて計画を更新。ブロッカーは早期に報告
4. **実装**: 対象を絞った編集を実施。小さな論理単位でコミット。必要でない限り大きなファイルの再生成は避ける
5. **検証**: 必要なコマンド（`pnpm lint`、`pnpm test`、`pnpm typecheck`など）のみ実行し、要約された出力を記録
6. **文書化とハンドオフ**: 挙動が変わる場合は README やドキュメントを更新。変更内容を要約し、実行したコマンドをリストアップ。PR を開く前にアーティファクト（ログ、スクリーンショット）を添付

## コミュニケーションとインシデント報告

- タスクスレッド内でブロッカーや曖昧さを報告。前提に基づいて進めない
- リグレッションや不安定なテストを発見した場合は、再現手順を含む Issue を作成し、関連するコードオーナーにアサイン
- インシデントやホットフィックスの後は、`docs/changelog.md`に学んだことを追記し、フォローアップのためにメンテナーに通知

## 追加リソース

- プロジェクトの詳細な説明については`AGENTS.md`を参照
- アーキテクチャノートとランブックについては`docs/`を参照
- コントリビューションガイドラインについては`README.md`を参照
